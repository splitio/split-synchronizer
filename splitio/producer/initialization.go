package producer

import (
	"errors"
	"fmt"
	"time"

	cconf "github.com/splitio/go-split-commons/v5/conf"
	"github.com/splitio/go-split-commons/v5/dtos"
	"github.com/splitio/go-split-commons/v5/flagsets"
	"github.com/splitio/go-split-commons/v5/provisional/strategy"
	"github.com/splitio/go-split-commons/v5/service/api"
	"github.com/splitio/go-split-commons/v5/storage/filter"
	"github.com/splitio/go-split-commons/v5/storage/inmemory"
	"github.com/splitio/go-split-commons/v5/storage/redis"
	"github.com/splitio/go-split-commons/v5/synchronizer"
	"github.com/splitio/go-split-commons/v5/synchronizer/worker/impressionscount"
	"github.com/splitio/go-split-commons/v5/synchronizer/worker/segment"
	"github.com/splitio/go-split-commons/v5/synchronizer/worker/split"
	"github.com/splitio/go-split-commons/v5/tasks"
	"github.com/splitio/go-split-commons/v5/telemetry"
	"github.com/splitio/go-toolkit/v5/logging"

	"github.com/splitio/split-synchronizer/v5/splitio/admin"
	adminCommon "github.com/splitio/split-synchronizer/v5/splitio/admin/common"
	"github.com/splitio/split-synchronizer/v5/splitio/common"
	"github.com/splitio/split-synchronizer/v5/splitio/common/impressionlistener"
	ssync "github.com/splitio/split-synchronizer/v5/splitio/common/sync"
	"github.com/splitio/split-synchronizer/v5/splitio/producer/conf"
	"github.com/splitio/split-synchronizer/v5/splitio/producer/evcalc"
	"github.com/splitio/split-synchronizer/v5/splitio/producer/storage"
	"github.com/splitio/split-synchronizer/v5/splitio/producer/task"
	"github.com/splitio/split-synchronizer/v5/splitio/producer/worker"
	hcApplication "github.com/splitio/split-synchronizer/v5/splitio/provisional/healthcheck/application"
	hcServices "github.com/splitio/split-synchronizer/v5/splitio/provisional/healthcheck/services"
	"github.com/splitio/split-synchronizer/v5/splitio/provisional/observability"
	"github.com/splitio/split-synchronizer/v5/splitio/util"
)

const (
	bfExpectedElemenets        = 10000000
	bfFalsePositiveProbability = 0.01
	bfCleaningPeriod           = 86400 // 6 hours
)

// Start initialize the producer mode
func Start(logger logging.LoggerInterface, cfg *conf.Main) error {
	// Getting initial config data
	advanced := cfg.BuildAdvancedConfig()
	advanced.FlagSetsFilter = cfg.FlagSetsFilter
	metadata := util.GetMetadata(false, cfg.IPAddressEnabled)

	clientKey, err := util.GetClientKey(cfg.Apikey)
	if err != nil {
		return common.NewInitError(fmt.Errorf("error parsing client key from provided SDK key: %w", err), common.ExitInvalidApikey)
	}

	// Setup fetchers & recorders
	splitAPI := api.NewSplitAPI(cfg.Apikey, *advanced, logger, metadata)

	// Check if SDK key is valid
	if !isValidApikey(splitAPI.SplitFetcher) {
		return common.NewInitError(errors.New("invalid SDK key"), common.ExitInvalidApikey)
	}

	// Redis Storages
	redisOptions, err := parseRedisOptions(&cfg.Storage.Redis)
	if err != nil {
		return common.NewInitError(fmt.Errorf("error parsing redis config: %w", err), common.ExitRedisInitializationFailed)
	}
	redisClient, err := redis.NewRedisClient(redisOptions, logger)
	if err != nil {
		return common.NewInitError(fmt.Errorf("error instantiating redis client: %w", err), common.ExitRedisInitializationFailed)
	}

	// Instantiating storages
	miscStorage := redis.NewMiscStorage(redisClient, logger)
	err = sanitizeRedis(cfg, miscStorage, logger)
	if err != nil {
		return common.NewInitError(fmt.Errorf("error cleaning up redis: %w", err), common.ExitRedisInitializationFailed)
	}

	// Handle dual telemetry:
	// - telemetry generated by split-sync
	// - telemetry generated by sdks and picked up by split-sync
	syncTelemetryStorage, _ := inmemory.NewTelemetryStorage()
	sdkTelemetryStorage := storage.NewRedisTelemetryCosumerclient(redisClient, logger)

	// FlagSetsFilter
	flagSetsFilter := flagsets.NewFlagSetFilter(cfg.FlagSetsFilter)

	// These storages are forwarded to the dashboard, the sdk-telemetry is irrelevant there
	splitStorage, err := observability.NewObservableSplitStorage(redis.NewSplitStorage(redisClient, logger, flagSetsFilter), logger)
	if err != nil {
		return fmt.Errorf("error instantiating observable feature flag storage: %w", err)
	}

	segmentStorage, err := observability.NewObservableSegmentStorage(logger, splitStorage, redis.NewSegmentStorage(redisClient, logger))
	if err != nil {
		return fmt.Errorf("error instantiating observable segment storage: %w", err)
	}
	storages := adminCommon.Storages{
		SplitStorage:          splitStorage,
		SegmentStorage:        segmentStorage,
		LocalTelemetryStorage: syncTelemetryStorage,
		ImpressionStorage:     redis.NewImpressionStorage(redisClient, dtos.Metadata{}, logger),
		EventStorage:          redis.NewEventsStorage(redisClient, dtos.Metadata{}, logger),
		UniqueKeysStorage:     redis.NewUniqueKeysMultiSdkConsumer(redisClient, logger),
	}

	// Healcheck Monitor
	splitsConfig, segmentsConfig, storageConfig := getAppCounterConfigs(storages.SplitStorage)
	appMonitor := hcApplication.NewMonitorImp(splitsConfig, segmentsConfig, &storageConfig, logger)
	servicesMonitor := hcServices.NewMonitorImp(getServicesCountersConfig(advanced), logger)

	impressionsCounter := strategy.NewImpressionsCounter()
	impressionObserver, err := strategy.NewImpressionObserver(impressionObserverSize)
	if err != nil {
		return common.NewInitError(fmt.Errorf("error instantiating impression observer: %w", err), common.ExitTaskInitialization)
	}

	// Creating Workers and Tasks
	eventEvictionMonitor := evcalc.New(1)

	workers := synchronizer.Workers{
		SplitUpdater: split.NewSplitUpdater(storages.SplitStorage, splitAPI.SplitFetcher, logger, syncTelemetryStorage, appMonitor, flagSetsFilter),
		SegmentUpdater: segment.NewSegmentUpdater(storages.SplitStorage, storages.SegmentStorage, splitAPI.SegmentFetcher,
			logger, syncTelemetryStorage, appMonitor),
		ImpressionsCountRecorder: impressionscount.NewRecorderSingle(impressionsCounter, splitAPI.ImpressionRecorder,
			metadata, logger, syncTelemetryStorage),
		// local telemetry
		TelemetryRecorder: telemetry.NewTelemetrySynchronizer(syncTelemetryStorage, splitAPI.TelemetryRecorder,
			storages.SplitStorage, storages.SegmentStorage, logger, metadata, syncTelemetryStorage),
	}
	splitTasks := synchronizer.SplitTasks{
		SplitSyncTask: tasks.NewFetchSplitsTask(workers.SplitUpdater, int(cfg.Sync.SplitRefreshRateMs)/1000, logger),
		SegmentSyncTask: tasks.NewFetchSegmentsTask(workers.SegmentUpdater, int(cfg.Sync.SegmentRefreshRateMs)/1000,
			advanced.SegmentWorkers, advanced.SegmentQueueSize, logger),
		ImpressionsCountSyncTask: tasks.NewRecordImpressionsCountTask(workers.ImpressionsCountRecorder,
			logger, impressionsCountPeriodTaskInMemory),
		// local telemetry
		TelemetrySyncTask: tasks.NewRecordTelemetryTask(workers.TelemetryRecorder, int(cfg.Sync.Advanced.InternalMetricsRateMs)/1000, logger),
	}

	impressionEvictionMonitor := evcalc.New(1)
	var impListener impressionlistener.ImpressionBulkListener
	if cfg.Integrations.ImpressionListener.Endpoint != "" {
		var err error
		impListener, err = impressionlistener.NewImpressionBulkListener(
			cfg.Integrations.ImpressionListener.Endpoint,
			int(cfg.Integrations.ImpressionListener.QueueSize),
			nil)
		if err != nil {
			return common.NewInitError(fmt.Errorf("error instantiating impression listener: %w", err), common.ExitTaskInitialization)
		}
		impListener.Start()
	}

	impManager := buildImpressionManager(cfg.Sync.ImpressionsMode, impListener, syncTelemetryStorage, impressionObserver, impressionsCounter)

	// Impression & events pipelined tasks @{
	impWorker, err := task.NewImpressionWorker(&task.ImpressionWorkerConfig{
		Logger:              logger,
		Storage:             storages.ImpressionStorage,
		EvictionMonitor:     impressionEvictionMonitor,
		URL:                 advanced.EventsURL,
		Apikey:              cfg.Apikey,
		ImpressionsListener: impListener,
		FetchSize:           int(cfg.Sync.Advanced.ImpressionsFetchSize),
		ImpressionManager:   impManager,
	})
	if err != nil {
		return common.NewInitError(fmt.Errorf("error instantiating impressions worker: %w", err), common.ExitTaskInitialization)
	}

	impTask, err := task.NewPipelinedTask(&task.Config{
		Name:               "impressions",
		Logger:             logger,
		Worker:             impWorker,
		ProcessConcurrency: cfg.Sync.Advanced.ImpressionsProcessConcurrency,
		ProcessBatchSize:   cfg.Sync.Advanced.ImpressionsProcessBatchSize,
		PostConcurrency:    cfg.Sync.Advanced.ImpressionsPostConcurrency,
		MaxAccumWait:       time.Duration(cfg.Sync.Advanced.ImpressionsAccumWaitMs) * time.Millisecond,
		HTTPTimeout:        time.Millisecond * time.Duration(cfg.Sync.Advanced.HTTPTimeoutMs),
	})
	if err != nil {
		return common.NewInitError(fmt.Errorf("error instantiating impressions pipelined task: %w", err), common.ExitTaskInitialization)
	}

	evWorker, err := task.NewEventsWorker(&task.EventWorkerConfig{
		Logger:          logger,
		Storage:         storages.EventStorage,
		URL:             advanced.EventsURL,
		EvictionMonitor: eventEvictionMonitor,
		Apikey:          cfg.Apikey,
		FetchSize:       int(cfg.Sync.Advanced.EventsFetchSize),
	})
	if err != nil {
		return common.NewInitError(fmt.Errorf("error instantiating events worker: %w", err), common.ExitTaskInitialization)
	}

	evTask, err := task.NewPipelinedTask(&task.Config{
		Name:               "events",
		Logger:             logger,
		Worker:             evWorker,
		ProcessConcurrency: cfg.Sync.Advanced.ImpressionsProcessConcurrency,
		ProcessBatchSize:   cfg.Sync.Advanced.ImpressionsProcessBatchSize,
		PostConcurrency:    cfg.Sync.Advanced.ImpressionsPostConcurrency,
		MaxAccumWait:       time.Duration(cfg.Sync.Advanced.EventsAccumWaitMs) * time.Millisecond,
		HTTPTimeout:        time.Millisecond * time.Duration(cfg.Sync.Advanced.HTTPTimeoutMs),
	})
	if err != nil {
		return common.NewInitError(fmt.Errorf("error instantiating events pipelined task: %w", err), common.ExitTaskInitialization)
	}

	filter := filter.NewBloomFilter(bfExpectedElemenets, bfFalsePositiveProbability)
	uniqueKeysTracker := strategy.NewUniqueKeysTracker(filter)
	uniquesWorker := task.NewUniqueKeysWorker(&task.UniqueWorkerConfig{
		Logger:            logger,
		Storage:           storages.UniqueKeysStorage,
		UniqueKeysTracker: uniqueKeysTracker,
		URL:               advanced.TelemetryServiceURL,
		Apikey:            cfg.Apikey,
		FetchSize:         int(cfg.Sync.Advanced.UniqueKeysFetchSize),
		Metadata:          metadata,
	})

	uniquesTask, err := task.NewPipelinedTask(&task.Config{
		Name:               "uniques",
		Logger:             logger,
		Worker:             uniquesWorker,
		ProcessConcurrency: cfg.Sync.Advanced.UniqueKeysProcessConcurrency,
		ProcessBatchSize:   cfg.Sync.Advanced.UniqueKeysProcessBatchSize,
		PostConcurrency:    cfg.Sync.Advanced.UniqueKeysPostConcurrency,
		MaxAccumWait:       time.Duration(cfg.Sync.Advanced.UniqueKeysAccumWaitMs) * time.Millisecond,
		HTTPTimeout:        time.Millisecond * time.Duration(cfg.Sync.Advanced.HTTPTimeoutMs),
	})
	if err != nil {
		return common.NewInitError(fmt.Errorf("error instantiating uniques pipelined task: %w", err), common.ExitTaskInitialization)
	}

	splitTasks.ImpressionSyncTask = impTask
	splitTasks.EventSyncTask = evTask
	splitTasks.UniqueKeysTask = uniquesTask
	splitTasks.CleanFilterTask = tasks.NewCleanFilterTask(filter, logger, bfCleaningPeriod)

	impcountStorageConsumer := redis.NewImpressionsCountStorage(redisClient, logger)
	impcountsWorker := worker.NewImpressionsCounstWorker(*impressionsCounter, impcountStorageConsumer, logger)
	splitTasks.ImpsCountConsumerTask = task.NewImpressionCountSyncTask(impcountsWorker, logger, int(cfg.Sync.Advanced.ImpressionsCountWorkerReadRateMs/1000))
	// @}

	sdkTelemetryWorker := worker.NewTelemetryMultiWorker(logger, sdkTelemetryStorage, splitAPI.TelemetryRecorder)
	sdkTelemetryTask := task.NewTelemetrySyncTask(sdkTelemetryWorker, logger, int(cfg.Sync.Advanced.TelemetryPushRateMs/1000))
	syncImpl := ssync.NewSynchronizer(*advanced, splitTasks, workers, logger, nil, []tasks.Task{sdkTelemetryTask})
	managerStatus := make(chan int, 1)
	syncManager, err := synchronizer.NewSynchronizerManager(
		syncImpl,
		logger,
		*advanced,
		splitAPI.AuthClient,
		storages.SplitStorage,
		managerStatus,
		syncTelemetryStorage,
		metadata,
		&clientKey,
		appMonitor,
	)

	if err != nil {
		return common.NewInitError(fmt.Errorf("error instantiating sync manager: %w", err), common.ExitTaskInitialization)
	}

	rtm := common.NewRuntime(false, syncManager, logger, "Split Synchronizer", nil, nil, appMonitor, servicesMonitor)

	// --------------------------- ADMIN DASHBOARD ------------------------------

	adminTLSConfig, err := util.TLSConfigForServer(&cfg.Admin.TLS)
	if err != nil {
		return common.NewInitError(fmt.Errorf("error setting up proxy TLS config: %w", err), common.ExitTLSError)
	}

	cfgForAdmin := *cfg
	cfgForAdmin.Apikey = logging.ObfuscateAPIKey(cfgForAdmin.Apikey)
	cfgForAdmin.Storage.Redis.Pass = "xxxxxxxxxxxxxxx"
	adminServer, err := admin.NewServer(&admin.Options{
		Host:              cfg.Admin.Host,
		Port:              int(cfg.Admin.Port),
		Name:              "Split Synchronizer dashboard",
		Proxy:             false,
		Username:          cfg.Admin.Username,
		Password:          cfg.Admin.Password,
		Logger:            logger,
		Storages:          storages,
		ImpressionsEvCalc: impressionEvictionMonitor,
		EventsEvCalc:      eventEvictionMonitor,
		Runtime:           rtm,
		HcAppMonitor:      appMonitor,
		HcServicesMonitor: servicesMonitor,
		FullConfig:        cfgForAdmin,
		TLS:               adminTLSConfig,
	})
	if err != nil {
		panic(err.Error())
	}
	go adminServer.Start()

	// Run Sync Manager
	before := time.Now()
	go syncManager.Start()
	select {
	case status := <-managerStatus:
		switch status {
		case synchronizer.Ready:
			logger.Info("Synchronizer tasks started")
			appMonitor.Start()
			servicesMonitor.Start()
			workers.TelemetryRecorder.SynchronizeConfig(
				telemetry.InitConfig{
					AdvancedConfig: *advanced,
					TaskPeriods: cconf.TaskPeriods{
						SplitSync:     int(cfg.Sync.SplitRefreshRateMs / 1000),
						SegmentSync:   int(cfg.Sync.SegmentRefreshRateMs / 1000),
						TelemetrySync: int(cfg.Sync.Advanced.InternalMetricsRateMs / 1000),
					},
					ImpressionsMode: cfg.Sync.ImpressionsMode,
					ListenerEnabled: impListener != nil,
				},
				time.Now().Sub(before).Milliseconds(),
				map[string]int64{cfg.Apikey: 1},
				nil,
			)
		case synchronizer.Error:
			logger.Error("Initial synchronization failed. Either Split is unreachable or the SDK key is incorrect. Aborting execution.")
			return common.NewInitError(fmt.Errorf("error instantiating sync manager: %w", err), common.ExitTaskInitialization)
		}
	}

	rtm.RegisterShutdownHandler()
	rtm.Block()
	return nil
}
